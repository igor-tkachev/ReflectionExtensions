<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".generated.cs" #>
//---------------------------------------------------------------------------------------------------
// <auto-generated>
//    This code was generated by ValueTuple.tt template for.
//    Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>
//---------------------------------------------------------------------------------------------------
#if NET20 || NET30 || NET35 || NET40 || NET45 || NET451 || NET452 || NET46 || NET461 || NET462 || NETSTANDARD1_0 || NETSTANDARD1_1 || NETSTANDARD1_2 || NETSTANDARD1_3 || NETSTANDARD1_4 || NETSTANDARD1_5 || NETSTANDARD1_6 || NETCOREAPP1_0 || NETCOREAPP1_1

using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.InteropServices;

namespace System
{
<#
var access    = "internal";
var tupleName = new[] { "", "singleton", "pair",   "triple", "quadruple", "quintuple", "sixtuple", "sentuple", "octuple" };
var numerals  = new[] { "", "first",     "second", "third",  "fourth",    "fifth",     "sixth",    "seventh",  "eighth"  };

string Build(int i, string begin, string end, Func<int,string> sFunc, Func<string,string,string> aFunc)
{
	return begin + Enumerable.Range(1, i).Select(sFunc).Aggregate(aFunc) + end;
}

for (var i = 1; i <= 7; i++)
{
	var typeName = "ValueTuple" + Build(i, "<", ">", n => $"T{n}", (s1,s2) => $"{s1},{s2}");
#>
<#
	if (i == 0)
	{
#>
	/// <summary>
	/// The ValueTuple types (from arity 0 to 8) comprise the runtime implementation that underlies tuples in C# and struct tuples in F#.
	/// Aside from created via language syntax, they are most easily created via the ValueTuple.Create factory methods.
	/// The System.ValueTuple types differ from the System.Tuple types in that:
	/// - they are structs rather than classes,
	/// - they are mutable rather than readonly, and
	/// - their members (such as Item1, Item2, etc) are fields rather than properties.
	/// </summary>
	[StructLayout(LayoutKind.Sequential, Size = 1)]
<#
	}
	else
	{
#>
	/// <summary>
	/// Represents a <#= i #>-tuple, or <#= tupleName[i] #>, as a value type.
	/// </summary>
	<#= Build(i, "", "", n => $"/// <typeparam name=\"T{n}\">The type of the tuple's {numerals[n]} component.</typeparam>", (s1,s2) => $"{s1}\r\n\t{s2}") #>
	[StructLayout(LayoutKind.Auto)]
<#
	}
#>
	<#= access #> readonly partial struct <#= typeName #> : IEquatable<<#= typeName #>>,
#if !NET20 && !NET30 && !NET35
		IStructuralEquatable, IStructuralComparable,
#endif
		IComparable, IComparable<<#= typeName #>>, ITupleInternal
	{
		/// <summary>
		/// Initializes a new instance of the <see cref="T:System.ValueTuple`<#= i #>" /> value type.
		/// </summary>
		<#= Build(i, "", "", n => $"/// <param name=\"item{n}\">The value of the tuple's {numerals[n]} component.</param>", (s1,s2) => $"{s1}\r\n\t\t{s2}") #>
		public ValueTuple(<#= Build(i, "", "", n => $"T{n} item{n}", (s1,s2) => $"{s1},{s2}") #>)
		{
			<#= Build(i, "", "", n => $"Item{n} = item{n};", (s1,s2) => $"{s1}\r\n\t\t\t{s2}") #>
		}

		<#= Build(i, "", "", n => $@"/// <summary>
		/// The current <see cref=""T:System.ValueTuple`{i}"" /> instance's {numerals[n]} component.
		/// </summary>
		public readonly T{n} Item{n};", (s1,s2) => $"{s1}\r\n\r\n\t\t{s2}") #>

		<#= Build(i, "", "", n => $"static readonly EqualityComparer<T{n}> _comparer{n} = EqualityComparer<T{n}>.Default;", (s1,s2) => $"{s1}\r\n\t\t{s2}") #>

		int System.ITupleInternal.Size => <#= i #>;

		/// <summary>
		/// Returns a value that indicates whether the current <see cref="T:System.ValueTuple`<#= i #>" /> instance is equal to a specified object.
		/// </summary>
		/// <param name="obj">The object to compare with this instance.</param>
		/// <returns><see langword="true" /> if the current instance is equal to the specified object; otherwise, <see langword="false" />.</returns>
		/// <remarks>
		/// The <paramref name="obj" /> parameter is considered to be equal to the current instance under the following conditions:
		/// <list type="bullet">
		///     <item><description>It is a <see cref="T:System.ValueTuple`<#= i #>" /> value type.</description></item>
		///     <item><description>Its components are of the same types as those of the current instance.</description></item>
		///     <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
		/// </list>
		/// </remarks>
		public override bool Equals(object obj)
		{
			return obj is <#= typeName #> v && Equals(v);
		}

		public bool Equals(<#= typeName #> other)
		{
			return <#= Build(i, "", "", n => $"_comparer{n}.Equals(Item{n}, other.Item{n})", (s1,s2) => $"{s1} && {s2}") #>;
		}

#if !NET20 && !NET30 && !NET35

		bool IStructuralEquatable.Equals(object other, IEqualityComparer comparer)
		{
			if (other == null || !(other is <#= typeName #> v)) return false;
			return <#= Build(i, "", "", n => $"comparer.Equals(Item{n}, v.Item{n})", (s1,s2) => $"{s1} && {s2}") #>;
		}

		int IStructuralEquatable.GetHashCode(IEqualityComparer comparer)
		{
			return ((ITupleInternal)this).GetHashCode(comparer);
		}

		int IStructuralComparable.CompareTo(object other, IComparer comparer)
		{
			if (other == null) return 1;

			if (!(other is <#= typeName #> v))
				throw new ArgumentException("Incorrect type of '<#= typeName #>'", "other");

			int num;

			<#= Build(i, "", "", n => $"num = comparer.Compare(Item{n}, v.Item{n}); if (num != 0) return num;", (s1,s2) => $"{s1}\r\n\t\t\t{s2}") #>

			return num;
		}

#endif

		int ITupleInternal.GetHashCode(IEqualityComparer comparer)
		{
<#
	if (i == 1)
	{
#>
			return comparer.GetHashCode(Item<#= i #>);
<#
	}
	else
	{
#>
			return ValueTuple.CombineHashCodes(
				<#= Build(i, "", "", n => $"comparer.GetHashCode(Item{n})", (s1,s2) => $"{s1},\r\n\t\t\t\t{s2}") #>);
<#
	}
#>
		}

		int IComparable.CompareTo(object other)
		{
			if (other == null) return 1;
			if (other is <#= typeName #> v) return CompareTo(v);

			throw new ArgumentException("Incorrect type of '<#= typeName #>'", "other");
		}

		public int CompareTo(<#= typeName #> other)
		{
			int num;

			<#= Build(i, "", "", n => $"num = Comparer<T{n}>.Default.Compare(Item{n}, other.Item{n}); if (num != 0) return num;", (s1,s2) => $"{s1}\r\n\t\t\t{s2}") #>

			return num;
		}

		/// <summary>
		/// Returns the hash code for the current <see cref="T:System.ValueTuple`<#= i #>" /> instance.
		/// </summary>
		/// <returns>A 32-bit signed integer hash code.</returns>
		public override int GetHashCode()
		{
<#
	if (i == 1)
	{
#>
			return _comparer1.GetHashCode(Item1);
<#
	}
	else
	{
#>
			return ValueTuple.CombineHashCodes(
				<#= Build(i, "", "", n => $"_comparer{n}.GetHashCode(Item{n})", (s1,s2) => $"{s1},\r\n\t\t\t\t{s2}") #>);
<#
	}
#>
		}

		string ITupleInternal.ToStringEnd()
		{
			return <#= Build(i, "\"\" +\r\n\t\t\t\t", "", n => $"((object)Item{n})", (s1,s2) => $"{s1} + \", \" +\r\n\t\t\t\t{s2}") #>;
		}

		public override string ToString()
		{
			return "(" + ((ITupleInternal)this).ToStringEnd() + ")";
		}
	}

<#
}

GenerationEnvironment.Length -= 2;
#>
}

#endif
